#tomcat配置
server:
  port: 8081
  servlet:
    context-path: /lms-lti-rollcall-sjtu


spring:
   #应用名称
  application:
    name: lms-lti-rollcall-sjtu

  main:
     #当遇到同样名字的依赖时，是否允许覆盖注册（默认是false，遇到冲突启动报错）
    allow-bean-definition-overriding: false


 #http配置
  http:
    encoding:
      charset: utf-8
      force: true
      enabled: true

  #数据源配置
  datasource:
    driver-class-name: org.postgresql.Driver
    username: dbuser
    password: 1q2w3e4r5t
    url: jdbc:postgresql://172.168.70.12:5432/dbuser?useUnicode=true&characterEncoding=utf8&useSSL=false
  druid:
   #连接池最大空间
  initial-size: 10
   #可用连接实例的最大数目
  max-active: 10
   #空闲连接实例的最小数目
  min-idle: 5


  #文件上传
  servlet:
    multipart:
      enabled: true
      max-file-size: 30MB
      max-request-size: 30MB



#mybatis配置
mybatis:
  #指定Dao层出入参所在的包进行自动扫描，实现mapper.xml类名简写
  type-aliases-package: com.example.demo.common
  configuration:
     #驼峰写法对应数据库字段的下划线
    map-underscore-to-camel-case: true
    #数据大小
    default-fetch-size: 100
    #超时时间
    default-statement-timeout: 30
    #指定mapper.xml资源路径
  mapper-locations: classpath:mapper/*.xml


#pagehelper分页插件配置
pagehelper:
   #连接的数据库类型
  helper-dialect: postgresql
   #设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是Page类型）
  page-size-zero: true
  #设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用，和startPage中的pageNum效果一样
  offset-as-page-num: true
 #设置为true时，使用RowBounds分页会进行count查询
  row-bounds-with-count: true
   #启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页
  reasonable: true
  supportMethodsArguments: true
  params: count=countSql


#  #redis配置
#  redis:
#    #好像是库的标号，通过标号可以切换redis缓存
#    database: 0
#    host: 127.0.0.1
#    port: 6380
#    #password: 900412
#    timeout: 20000
#    #集群配置信息
#    cluster:
#      nodes: 127.0.0.1:6380,127.0.0.1:6381,127.0.0.1:6382,127.0.0.1:6383,127.0.0.1:6384,127.0.0.1:6385
#      #默认值是5 一般当此值设置过大时，容易报：Too many Cluster redirections
#      maxRedirects: 3
#    #是否启用SSL协议支持
#    ssl: false
#    jedis:
#      pool:
#        #持在给定时间可以分配的最大连接数。使用负值表示无限制
#        max-active: 8
#        #池中“空闲”连接的最大数量。使用负值表示无限制
#        max-idle: 8
#        #目标是池中维护的最小空闲连接数。此设置仅在期为正数时才有效
#        min-idle: 0
#        #当池耗尽时，在抛出异常之前连接分配应该阻塞的最长时间。使用负值表示无限期阻止
#        max-wait: -1


  #session配置
#  session:
#    #选择使用redis作为session存储
#    store-type: redis
#    hazelcast:
#      #设置存储格式
#      map-name: spring:session:demo
#    redis:
#      #设置session刷新ON_SAVE（表示在response commit前刷新缓存），IMMEDIATE（表示只要有更新，便刷新缓存）
#      flush-mode: on_save


  #RabbitMQ配置
  # 描述：有了此配置后spring boot会自动创建ConnectionFactory以及RabbitTemplate对应的Bean。
  #      而我这里采用了非自动配置，即手动将这些参数引入到自定义ConnectionFactory的java配置类中。而使用@RabbitListener注解的监听器则会默认使用下面的yml监听配置，
  #      如果想重新定义监听器配置，则需要使用java配置bean方式自定义一个监听器SimpleMessageListenerContainer或者统一自定义监听器工厂SimpleRabbitListenerContainerFactory。
  # 注意：重新自定义的监听器工厂SimpleRabbitListenerContainerFactory配置会覆盖yml监听配置，直接改变@RabbitListener注解监听策略；
  #      而自定义一个监听器SimpleMessageListenerContainer不会覆盖yml配置，不影响@RabbitListener注解监听策略。
#  rabbitmq:
#    host: 127.0.0.1
#    port: 5672
#    username: guest
#    password: guest
#    virtual-host: /
#    #发布者开启消息确认机制（即消息回调）
#    publisher-confirms: true
#    publisher-returns: true
#    #设置监听器
#    listener:
#      simple:
#        #重试次数超过上面的设置之后是否丢弃（false不丢弃时需要写相应代码将该消息加入死信队列）
#        default-requeue-rejected: false
#        retry:
#          #监听器开启手动ack（手动签收），rabbitMQ默认模式是自动应答
#          acknowledge-mode: manual
#          #开启消费者进行重试（程序出现异常的情况下才会），这种间隔是单线程的，不存在并发问题。默认是无限循环重试模式。
#          enabled: true
#          #最大重试次数
#          max-attempts: 5
#          #重试间隔时间5秒
#          initial-interval: 5000
#          #重试最大时间间隔（单位毫秒）
#          max-interval: 1200000
#          #应用于前一重试间隔的乘法器
#          multiplier: 5


#eureka配置
#eureka:
#  instance:
#    hostname: localhost
#  #Not a client，don't register with yourself
#  client:
#    register-with-eureka: false
#    fetch-registry: false




#Apache的HttpClient配置参数（非自动配置，需手动将参数配到HttpClientConfig配置类中）
#http:
#  #最大连接数
#  maxTotal: 100
#  #并发数
#  defaultMaxPerRoute: 20
#  #创建连接的最长时间
#  connectTimeout: 1000
#  #从连接池中获取到连接的最长时间
#  connectionRequestTimeout: 500
#  #数据传输的最长时间
#  socketTimeout: 10000
#  #提交请求前测试连接是否可用
#  staleConnectionCheckEnabled: true
